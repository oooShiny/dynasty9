<?php

/**
 * @file
 * Provides integration with the Gutenberg editor.
 */

use Drupal\Component\Utility\Html;
use Drupal\Core\Access\CsrfRequestHeaderAccessCheck;
use Drupal\Core\Ajax\AjaxResponse;
use Drupal\Core\Ajax\CloseModalDialogCommand;
use Drupal\Core\Entity\EntityFormInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Language\LanguageInterface;
use Drupal\Core\Render\Markup;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\gutenberg\Ajax\UpdateMediaEntitiesCommand;
use Drupal\gutenberg\Controller\UtilsController;
use Drupal\gutenberg\MappingFieldsHelper;
use Drupal\gutenberg\GutenbergElementInfoAlter;
use Drupal\image\Entity\ImageStyle;
use Drupal\media\MediaForm;
use Drupal\node\NodeInterface;
use Drupal\views\ViewExecutable;
use Drupal\Core\Asset\AttachedAssetsInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\gutenberg\ContentBlocksHandler;
use Drupal\gutenberg\StyleEngine;

// <editor-fold desc="Gutenberg autogenerated code.">
define('GUTENBERG_JS_VERSION', '16.7.0-rc.1');
define('GUTENBERG_JS_GIT_COMMIT', 'fb3a11411cc4cc3af8a3c2a629842d1c63d8edbc');
// </editor-fold>

/**
 * Implements hook_theme().
 */
function gutenberg_theme() {
  $templates = [
    'page__node__edit__gutenberg' => [
      'template' => 'page--node--edit--gutenberg',
    ],
    'page__node__add__gutenberg' => [
      'template' => 'page--node--add--gutenberg',
    ],
    'node_edit_form__gutenberg' => [
      'template' => 'node-edit-form--gutenberg',
    ],
    // To avoid the add more button to be rendered in modal footer.
    // @todo: We need this template until https://www.drupal.org/project/drupal/issues/3089751 is fixed.
    'field_multiple_value_form__gutenberg' => [
      'template' => 'field-multiple-value-form--gutenberg',
      'base hook' => 'field_multiple_value_form',
      'render element' => 'element',
    ],
    // Gutenberg text field.
    'field_gutenberg_text' => [
      'render element' => 'element',
      'file' => 'gutenberg.theme.inc',
    ],
    'gutenberg_block' => [
      'variables' => [
        'block_name' => NULL,
        'block_attributes' => [],
        'block_content' => NULL,
      ],
      'file' => 'gutenberg.theme.inc',
    ],
  ];

  // Generate theme definitions for each module's dynamic block.
  /*
   * By default, Drupal 8 does not include theme suggestions from inside the
   * module in which they were created, so we must add them manually here.
   */
  $base_hook = 'gutenberg_block';
  /** @var \Drupal\gutenberg\GutenbergLibraryManagerInterface $gutenberg_library_manager */
  $gutenberg_library_manager = \Drupal::service('plugin.manager.gutenberg.library');
  foreach ($gutenberg_library_manager->getModuleDefinitions() as $module => $definition) {
    if (empty($definition['dynamic-blocks'])) {
      // No dynamic blocks to declare.
      continue;
    }

    $template_hooks = drupal_find_theme_templates(
      $templates,
      '.html.twig',
      \Drupal::service('extension.list.module')->getPath($module) . '/templates'
    );

    foreach ($definition['dynamic-blocks'] as $block_name => $block_theme_definition) {
      $block_name = str_replace('-', '_', $block_name);
      $block_parts = explode('/', $block_name);
      $hook_names = [$block_parts[0]];
      if (count($block_parts) === 2) {
        // namespace/blockname.
        $hook_names[] = $block_parts[0] . '__' . $block_parts[1];
      }

      foreach ($hook_names as $hook_name) {
        $theme_hook_name = $base_hook . '__' . $hook_name;

        if (!isset($templates[$theme_hook_name]) &&
          isset($template_hooks[$theme_hook_name])) {
          // Add the module's theme definition if the template exists.
          $template_hooks[$theme_hook_name]['type'] = 'module';
          $templates[$theme_hook_name] = $block_theme_definition + $template_hooks[$theme_hook_name];
        }
      }

    }
  }

  return $templates;
}

/**
 * Implements hook_theme_suggestions_HOOK().
 */
function gutenberg_theme_suggestions_gutenberg_block(array $variables) {
  $block_name = str_replace('-', '_', $variables['block_name']);
  $block_parts = explode('/', $block_name);
  $suggestions = [];

  $base_hook = 'gutenberg_block__';
  $suggestions[] = $base_hook . $block_parts[0];
  if (count($block_parts) === 2) {
    // namespace/blockname format.
    $suggestions[] = $base_hook . $block_parts[0] . '__' . $block_parts[1];
  }

  return $suggestions;
}

/**
 * Implements hook_js_alter().
 */
function gutenberg_js_alter(&$javascript, AttachedAssetsInterface $assets) {
  // For an unknown reason the scripts that depend on jquery.ui.widget are
  // loaded before its dependency. Therefore we modify the weight here to
  // ensure the widget-min.js is invoked earlier.
  // See https://www.drupal.org/project/gutenberg/issues/3219569
  if (isset($javascript['core/assets/vendor/jquery.ui/ui/widget-min.js'])) {
    $javascript['core/assets/vendor/jquery.ui/ui/widget-min.js']['weight'] = -12;
  }
}

/**
 * Implements hook_form_alter().
 */
function gutenberg_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  /* TODO: Simplify large alter functions like this using specific classes:
   * https://drupal.stackexchange.com/questions/238341
   * @see content_moderation_form_alter()
   */
  $form_object = $form_state->getFormObject();
  if ($form_object instanceof MediaForm && $form_object->getOperation() === 'edit') {
    _gutenberg_media_form_alter($form, $form_state, $form_id);
  }

  if ($form_id == 'node_type_edit_form' || $form_id == 'node_type_add_form') {
    $config = \Drupal::service('config.factory')->getEditable('gutenberg.settings');

    $form['gutenberg'] = [
      '#type' => 'details',
      '#title' => t('Gutenberg experience'),
      '#description' => '',
      '#group' => 'additional_settings',
      '#weight' => 999,
      'enable_gutenberg_experience' => [
        '#type' => 'checkbox',
        '#title' => t('Enable Gutenberg experience'),
        '#description' => t('Turn the node edit form into a full Gutenberg UI experience. At least one field of long text type is necessary.'),
        '#default_value' => $config->get($form['type']['#default_value'] . '_enable_full'),
      ],
    ];

    $form['gutenberg']['categories'] = [
      '#type' => 'hidden',
      '#default_value' => [],
    ];

    $example_code = '<code>
<pre>[
  ["core/heading", {}],
  ["core/paragraph", {"placeholder": "Insert text"}]
]</pre></code>';

    $form['gutenberg']['gutenberg_template'] = [
      '#type' => 'textarea',
      '#description' => t('JSON structure of blocks. Example: @example_code', [
        '@example_code' => Markup::create($example_code),
      ]),
      '#title' => t('Template'),
      '#default_value' => $config->get($form['type']['#default_value'] . '_template'),
      '#states' => [
        'visible' => [
          'input[name="enable_gutenberg_experience"]' => ['checked' => TRUE],
        ],
      ],
    ];

    /*
     * TODO add validation on this.
     *  Enforcing the "None" lock if the template is empty.
     */
    $form['gutenberg']['gutenberg_template_lock'] = [
      '#type' => 'select',
      '#title' => t('Template lock'),
      '#description' => t('<code>All</code> will fully lock the page template, not able to delete, create or move blocks just edit the content.<br/><code>Insert</code> will allow moving blocks.'),
      '#default_value' => $config->get($form['type']['#default_value'] . '_template_lock'),
      '#options' => [
        'none' => t('None'),
        'insert' => t('Insert'),
        'all' => t('All'),
      ],
      '#states' => [
        'visible' => [
          'input[name="enable_gutenberg_experience"]' => ['checked' => TRUE],
        ],
      ],
    ];

    $form['gutenberg']['allowed_blocks_details'] = [
      '#type' => 'details',
      '#title' => t('Allowed Gutenberg blocks'),
      '#states' => [
        'visible' => [
          'input[name="enable_gutenberg_experience"]' => ['checked' => TRUE],
        ],
      ],
    ];

    $settings = UtilsController::getAllowedBlocks();
    $blocks_settings = UtilsController::getBlocksSettings();

    foreach ($settings['categories'] as $category) {
      $category['reference'] = str_replace('/', '-', $category['reference']);
      $form['gutenberg']['categories']['#default_value'][] = $category['reference'];

      $form['gutenberg']['allowed_blocks_details'][$category['reference']] = [
        '#type' => 'fieldset',
        '#title' => $category['name'],
      ];

      $options = [$category['reference'] . '/all' => t('All')];
      $disabled_blocks = [];
      foreach ($category['blocks'] as $block) {
        if (!in_array($block['id'], $blocks_settings['blacklist'])) {
          $options[$block['id']] = $block['name'];
          if (isset($block['disabled']) && $block['disabled']) {
            $disabled_blocks[$block['id']] = ['disabled' => 'disabled'];
          }
        }
      }

      $default_values = array_combine(
        array_map(
          function ($block) {
            return $block['id'];
          },
          $category['blocks']
        ),
        array_map(
          function ($block) {
            return $block['default'] ? $block['id'] : 0;
          },
          $category['blocks']
        )
      );

      $config_values = $config->get($form['type']['#default_value'] . '_allowed_blocks');

      $form['gutenberg']['allowed_blocks_details'][$category['reference']]['allowed_blocks_' . $category['reference']] = [
        '#type' => 'checkboxes',
        '#options' => $options,
        '#default_value' => $config_values ? $config_values : $default_values,
        '#disabled_blocks' => $disabled_blocks,
      ];

      $form['gutenberg']['allowed_blocks_details'][$category['reference']]['allowed_blocks_' . $category['reference']]['#after_build'][] = 'gutenberg_process_allowed_blocks_checkboxes';
    }

    $custom_settings = UtilsController::getAllowedCustomBlocks();

    if ($custom_settings) {
      $form['gutenberg']['allowed_custom_blocks_details'] = [
        '#type' => 'details',
        '#title' => t('Allowed Custom Gutenberg blocks'),
        '#states' => [
          'visible' => [
            'input[name="enable_gutenberg_experience"]' => ['checked' => TRUE],
          ],
        ],
      ];

      foreach ($custom_settings['categories'] ?? [] as $category) {
        $category['reference'] = str_replace('/', '-', $category['reference']);
        $form['gutenberg']['categories']['#default_value'][] = $category['reference'];

        $form['gutenberg']['allowed_custom_blocks_details'][$category['reference']] = [
          '#type' => 'fieldset',
          '#title' => $category['name'],
        ];

        $options = [$category['reference'] . '/all' => t('All')];
        foreach ($category['blocks'] as $block) {
          $options[$block['id']] = $block['name'];
        }

        $default_values = array_combine(
          array_map(
            function ($block) {
              return $block['id'];
            },
            $category['blocks']
          ),
          array_map(
            function ($block) {
              return isset($block['default']) && $block['default'] ? $block['id'] : 0;
            },
            $category['blocks']
          )
        );

        $config_values = $config->get($form['type']['#default_value'] . '_allowed_blocks');

        $form['gutenberg']['allowed_custom_blocks_details'][$category['reference']]['allowed_blocks_' . $category['reference']] = [
          '#type' => 'checkboxes',
          '#options' => $options,
          '#default_value' => array_merge($default_values, $config_values ? $config_values : []),
        ];
      }
    }

    $form['gutenberg']['allowed_drupal_blocks_details'] = [
      '#type' => 'details',
      '#title' => t('Allowed Drupal blocks'),
      '#states' => [
        'visible' => [
          'input[name="enable_gutenberg_experience"]' => ['checked' => TRUE],
        ],
      ],
    ];

    $blockManager = \Drupal::service('plugin.manager.block');
    $contextRepository = \Drupal::service('context.repository');

    // Get blocks definition
    // $definitions = $blockManager->getDefinitionsForContexts($contextRepository->getAvailableContexts());
    $definitions = $blockManager->getFilteredDefinitions('block_ui', $contextRepository->getAvailableContexts());
    $groups = $blockManager->getGroupedDefinitions($definitions);

    $form['gutenberg']['categories_drupal'] = [
      '#type' => 'hidden',
      '#default_value' => [],
    ];

    $default_values = array_fill_keys(
      array_map(function ($key) {
        return str_replace('drupalblock/', '', $key);
      }, $settings['default_drupal_blocks']),
      TRUE
    );

    foreach ($groups as $key => $blocks) {
      $group_reference = preg_replace('@[^a-z0-9-]+@', '_', strtolower($key));
      $options = [];
      $input_default_values = [];

      $options = ['drupalblock/all_' . $group_reference => t('All')];

      foreach ($blocks as $key_block => $block) {
        if (!in_array('drupalblock/' . $key_block, $blocks_settings['blacklist'])) {
          $options[$key_block] = $block['admin_label'];
          if (isset($default_values[$key_block]) && $default_values[$key_block]) {
            $input_default_values[$key_block] = $key_block;
          }
        }
      }

      if (count($options) > 0) {
        $form['gutenberg']['categories_drupal']['#default_value'][] = $group_reference;
        $form['gutenberg']['allowed_drupal_blocks_details'][$group_reference] = [
          '#type' => 'fieldset',
          '#title' => $key,
        ];

        $config_values = $config->get($form['type']['#default_value'] . '_allowed_drupal_blocks');

        $form['gutenberg']['allowed_drupal_blocks_details'][$group_reference]['allowed_drupal_blocks_' . $group_reference] = [
          '#type' => 'checkboxes',
          '#options' => $options,
          '#default_value' => array_merge($input_default_values, $config_values ? $config_values : []),
        ];
      }
    }

		// Get drupal image styles
		$gutenberg_image_styles['full'] = t('Original');
		$gutenberg_image_styles_default_values = ['full'];
		$gutenberg_image_styles_config_values = $config->get($form['type']['#default_value'] . '_allowed_image_styles');
		$drupal_styles = ImageStyle::loadMultiple();
		if (!empty($drupal_styles)) {
			foreach ($drupal_styles as $style) {
				$gutenberg_image_styles[$style->getName()] = $style->label();
				$gutenberg_image_styles_default_values[] = $style->getName();
			}
		}

		// Allowed image styles
		$form['gutenberg']['allowed_image_styles_details'] = [
			'#type' => 'details',
			'#title' => t('Allowed Image Styles / Sizes'),
			'#states' => [
				'visible' => [
					'input[name="enable_gutenberg_experience"]' => ['checked' => TRUE],
				],
      ],
    ];

		$form['gutenberg']['allowed_image_styles_details']['allowed_image_styles'] = [
			'#type' => 'checkboxes',
			'#options' => $gutenberg_image_styles,
			'#default_value' => $gutenberg_image_styles_config_values ?: $gutenberg_image_styles_default_values,
		];

    // Content block types.
    $form['gutenberg']['allowed_content_block_types_details'] = [
      '#type' => 'details',
      '#title' => t('Allowed content block types'),
      '#description' => t('Select the content block types that can be created in the Gutenberg editor.'),
      '#states' => [
        'visible' => [
          'input[name="enable_gutenberg_experience"]' => ['checked' => TRUE],
        ],
      ],
    ];

    // If the media module is enabled, let's make it possible to turn on or off
    // that as well.
    /** @var \Drupal\Core\Extension\ModuleHandlerInterface $module_handler */
    $module_handler = \Drupal::service('module_handler');
    if ($module_handler->moduleExists('media')) {
      $form['gutenberg']['allowed_drupal_blocks_details']['media'] = [
        '#type' => 'fieldset',
        '#title' => t('Media'),
      ];
      $default_values = [
        'drupalmedia/drupal-media-entity' => isset($config_values) && is_array($config_values) && in_array('drupalmedia/drupal-media-entity', $config_values) ? 'drupalmedia/drupal-media-entity' : FALSE,
      ];
      $form['gutenberg']['allowed_drupal_blocks_details']['media']['allowed_drupal_blocks_media'] = [
        '#type' => 'checkboxes',
        '#options' => [
          'drupalmedia/drupal-media-entity' => t('Media'),
        ],
        '#default_value' => $default_values,
      ];
      $form['gutenberg']['categories_drupal']['#default_value'][] = 'media';
    }

    // Get content block types.
    // $blockManager = \Drupal::service('plugin.manager.block');
    $entityTypeManager = \Drupal::service('entity_type.manager');
    $types = $entityTypeManager->getStorage('block_content_type')->loadMultiple();

    $config_values = $config->get($form['type']['#default_value'] . '_allowed_content_block_types');

    $options = ['content-block/all' => t('All')];
    foreach ($types as $key => $type) {
      if (
        !in_array('content-block/' . $key, $blocks_settings['blacklist'])
        && $key !== 'reusable_block'
      ) {
        $options['content-block/' . $key] = $type->label();
        if (isset($default_values[$key])) {
          $input_default_values['content-block/' . $key] = $type->label();
        }
      }
    }
    $form['gutenberg']['allowed_content_block_types_details']['allowed_content_block_types'] = [
      '#type' => 'checkboxes',
      '#options' => $options,
      '#default_value' => array_merge($input_default_values, $config_values ? $config_values : []),
    ];

    $form['#attached']['library'][] = 'gutenberg/admin';
    $form['actions']['submit']['#submit'][] = '_gutenberg_node_type_form_submit';

    if (isset($form['actions']['save_continue']['#submit'])) {
      $form['actions']['save_continue']['#submit'][] = '_gutenberg_node_type_form_submit';
    }
  }
}

/**
 * Process allowed blocks checkboxes.
 * The ones disabled are checked and disabled.
 *
 * @param array $element
 *   Render element.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   Form state object.
 * @return array
 *   Processed render element.
 */
function gutenberg_process_allowed_blocks_checkboxes($element, FormStateInterface $form_state) {
  $disabled_blocks = $element['#disabled_blocks'];

  foreach ($element['#options'] as $key => $value) {
    if (isset($disabled_blocks[$key])) {
      $element[$key]['#attributes'] = [
        'disabled' => 'disabled',
        'checked' => 'checked',
      ];
    }
  }

  return $element;
}

/**
 * Alters the node form submit.
 *
 * @param array $form
 *   The form definition array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The current state of the form.
 */
function _gutenberg_node_type_form_submit(array $form, FormStateInterface $form_state) {
  $gutenberg_enabled = (bool) $form_state->getValue('enable_gutenberg_experience');
  $template = $form_state->getValue('gutenberg_template');
  $template_lock = $form_state->getValue('gutenberg_template_lock');

  $config = \Drupal::service('config.factory')->getEditable('gutenberg.settings');
  $config->set($form_state->getValue('type') . '_enable_full', $gutenberg_enabled)->save();

  if (!$gutenberg_enabled) {
    $config->clear($form_state->getValue('type') . '_allowed_blocks')->save();
    $config->clear($form_state->getValue('type') . '_allowed_drupal_blocks')->save();
    $config->clear($form_state->getValue('type') . '_allowed_content_block_types')->save();
    $config->clear($form_state->getValue('type') . '_gutenberg_template')->save();
    $config->clear($form_state->getValue('type') . '_gutenberg_template_lock')->save();
    return;
  }
  // Save template settings.
  $config->set($form_state->getValue('type') . '_template', $template)->save();
  $config->set($form_state->getValue('type') . '_template_lock', $template_lock)->save();

  // Save Gutenberg core blocks settings.
  $categories = explode(' ', $form_state->getValue('categories'));
  $values = [];
  foreach ($categories as $category) {
    $values[] = (array) $form_state->getValue('allowed_blocks_' . $category);
  }
  $values = array_merge(...$values);
  $values = array_keys(array_filter($values));
  sort($values, SORT_FLAG_CASE);
  $config->set($form_state->getValue('type') . '_allowed_blocks', $values)->save();

  // Save Drupal blocks settings.
  $categories = explode(' ', $form_state->getValue('categories_drupal'));
  $values = [];
  foreach ($categories as $category) {
    $values[] = (array) $form_state->getValue('allowed_drupal_blocks_' . $category);
  }
  $values = array_merge(...$values);
  $values = array_keys(array_filter($values));
  sort($values, SORT_FLAG_CASE);
  $config->set($form_state->getValue('type') . '_allowed_drupal_blocks', $values)->save();

	// Save image styles
	$config->set($form_state->getValue('type') . '_allowed_image_styles', $form_state->getValue('allowed_image_styles'))->save();

  $values = $form_state->getValue('allowed_content_block_types');
  $values = array_keys(array_filter($values));
  sort($values, SORT_FLAG_CASE);
  $config->set($form_state->getValue('type') . '_allowed_content_block_types', $values)->save();
}

/**
 * Implements hook_config_schema_info_alter().
 */
function gutenberg_config_schema_info_alter(&$definitions) {
  // @todo this isn't ideal, the field names should not be dynamic.
  // Loading the fields directly from the settings rather than the Node types
  // in case there are optional Node types that have to have their
  // configurations persisted in installation profiles/distributions.
  foreach (array_keys(Drupal::config('gutenberg.settings')->get()) as $property) {
    if (str_ends_with($property, '_enable_full')) {
      $definitions['gutenberg.settings']['mapping'][$property] = [
        'type' => 'boolean',
        'label' => 'Gutenberg enabled',
      ];
    }
    elseif (str_ends_with($property, '_template')) {
      $definitions['gutenberg.settings']['mapping'][$property] = [
        'type' => 'string',
        'label' => 'Template',
      ];
    }
    elseif (str_ends_with($property, '_template_lock')) {
      $definitions['gutenberg.settings']['mapping'][$property] = [
        'type' => 'string',
        'label' => 'Template lock',
      ];
    }
    elseif (str_ends_with($property, '_allowed_blocks')) {
      $definitions['gutenberg.settings']['mapping'][$property] = [
        'type' => 'sequence',
        'label' => 'Allowed blocks',
        'sequence' => [
          [
            'type' => 'string',
            'label' => 'Allowed block',
          ],
        ],
      ];
    }
    elseif (str_ends_with($property, '_allowed_drupal_blocks')) {
      $definitions['gutenberg.settings']['mapping'][$property] = [
        'type' => 'sequence',
        'label' => 'Allowed Drupal blocks',
        'sequence' => [
          [
            'type' => 'string',
            'label' => 'Allowed Drupal block',
          ],
        ],
      ];
    }
    elseif (str_ends_with($property, '_allowed_content_block_types')) {
      $definitions['gutenberg.settings']['mapping'][$property] = [
        'type' => 'sequence',
        'label' => 'Allowed Content Block blocks',
        'sequence' => [
          [
            'type' => 'string',
            'label' => 'Allowed content block type',
          ],
        ],
      ];
    }
  }
  if (!empty($definitions['gutenberg.settings']['mapping'])) {
    // Sort the fields in alphabetical order.
    ksort($definitions['gutenberg.settings']['mapping'], SORT_ASC);
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for \Drupal\node\NodeForm.
 *
 * Hides mapping fields.
 */
function gutenberg_form_node_form_alter(&$form, FormStateInterface $form_state) {
  $node = $form_state->getFormObject()->getEntity();

  if (!_gutenberg_is_gutenberg_enabled($node)) {
    // Leave early if Gutenberg is not enabled for this entity.
    return;
  }

  // @todo: This is needed since we are dependent on the theme hook
  // node_edit_form. This is added by the claro theme in the
  // claro_form_node_form_alter function. We should remove this hidden
  // dependency so this can be more predictable. See
  // https://www.drupal.org/project/gutenberg/issues/3472707 for more details
  // and possibly followups.
  if (empty($form['#theme'])) {
    $form['#theme'] = [];
  }
  if (!in_array('node_edit_form', $form['#theme'])) {
    $form['#theme'][] = 'node_edit_form';
  }

  $config = \Drupal::service('config.factory')->get('gutenberg.settings');
  $node_type = $node->type->getString();
  $node_type_entity = $node->type[0]->entity;
  $text_fields = UtilsController::getEntityTextFields($node);

  // Mark form as Gutenberg enabled.
  $form['#gutenberg_enabled'] = TRUE;
  $form['#attributes']['data-gutenberg-enabled'] = TRUE;

  // Set template options to global var.
  $gutenberg_template = $config->get($node_type . '_template') ? json_decode($config->get($node_type . '_template')) : NULL;
  $form['#attached']['drupalSettings']['gutenberg']['entityId'] = $node->id();
  $form['#attached']['drupalSettings']['gutenberg']['nodeType'] = $node_type;
  $form['#attached']['drupalSettings']['gutenberg']['nodeTypeLabel'] = $node_type_entity->label();
  $form['#attached']['drupalSettings']['gutenberg']['template'] = $gutenberg_template;
  $form['#attached']['drupalSettings']['gutenberg']['template-lock'] = $config->get($node_type . '_template_lock');
  $form['#attached']['drupalSettings']['gutenberg']['csrfToken'] = \Drupal::csrfToken()->get(CsrfRequestHeaderAccessCheck::TOKEN_KEY);

  /** @var \Drupal\gutenberg\MappingFieldsHelper $mapping_fields */
  $mapping_fields = \Drupal::service('class_resolver')
    ->getInstanceFromDefinition(MappingFieldsHelper::class);

  $mapped_fields = $mapping_fields->getMappedFields($gutenberg_template);
  $content_mapped_fields = $mapping_fields->getMappedFieldsFromContent($node->get($text_fields[0])->value);

  // Merge tempalte mapped fields with content mapped fields.
  $mapped_fields = array_merge($mapped_fields, $content_mapped_fields);

  $mapping_fields_settings = [];
  foreach ($mapped_fields as $item) {
    // We don't need these form field items because those fields will be
    // handled on entity presave.
    $form[$item['field']]['#access'] = FALSE;

    $field_definition = $node->get($item['field'])->getFieldDefinition();

    $mapping_fields_settings[$item['field']] = [
      'name' => $field_definition->getName(),
      'label' => $field_definition->getLabel(),
      'type' => $field_definition->getType(),
      'required' => $field_definition->isRequired(),
      'translatable' => $field_definition->isTranslatable(),
      'value' => $node->get($item['field'])->getValue(),
    ];
  }

  $form['#validate'][] = [$mapping_fields, 'validateMappedFields'];

  $form['#attached']['drupalSettings']['gutenberg']['mappingFields'] = $mapping_fields_settings;

  /** @var \Drupal\gutenberg\GutenbergLibraryManagerInterface $gutenberg_library_manager */
  $gutenberg_library_manager = \Drupal::service('plugin.manager.gutenberg.library');
  $module_definitions = $gutenberg_library_manager->getModuleDefinitions();

  foreach ($module_definitions as $module_definition) {
    if (isset($module_definition['libraries-edit'])) {
      foreach ($module_definition['libraries-edit'] as $library) {
        $form['#attached']['library'][] = $library;
      }
    }
  }

  $theme_support = [];
  $theme_definitions = $gutenberg_library_manager->getActiveThemeDefinitions();
  foreach ($theme_definitions as $theme_definition) {
    if (isset($theme_definition['libraries-edit'])) {
      foreach ($theme_definition['libraries-edit'] as $library) {
        $form['#attached']['library'][] = $library;
      }
    }
    if (isset($theme_definition['theme-support'])) {
      // Merge only the top level configuration, with the child theme
      // taking precedence.
      $theme_support = $theme_definition['theme-support'] + $theme_support;
    }
  }
  // Blocks lock permission.
  $theme_support['canLockBlocks'] = \Drupal::currentUser()->hasPermission('manage blocks lock');

  $form['#attached']['drupalSettings']['gutenberg']['theme-support'] = $theme_support;

  // Set available image sizes for editor.
  $allowed_styles = $config->get($node_type . '_allowed_image_styles');
  $sizes = [];
  if (!empty($allowed_styles['full'])) {
    $sizes = [
      [
        'slug' => 'full',
        'name' => t('Original'),
      ],
    ];
  }
  $styles = ImageStyle::loadMultiple();
  if (!empty($styles)) {
    foreach ($styles as $style) {
      if (!empty($allowed_styles[$style->getName()])) {
        $sizes[] = [
          'slug' => $style->getName(),
          'name' => $style->label(),
        ];
      }
    }
  }
  $form['#attached']['drupalSettings']['gutenberg']['image-sizes'] = $sizes;

  $form['#attached']['drupalSettings']['gutenberg']['is-rtl'] =
    \Drupal::languageManager()->getCurrentLanguage()->getDirection() === LanguageInterface::DIRECTION_RTL;

  $form['#attributes']['class'][] = 'metabox-base-form';

  $form[$text_fields[0]]['widget'][0]['#format'] = 'gutenberg';
  $form[$text_fields[0]]['#attributes']['class'][] = 'field--gutenberg';

  // Hide the field label.
  $form[$text_fields[0]]['widget'][0]['#title_display'] = 'hidden';

  // Call after build for the field.
  $form[$text_fields[0]]['widget']['#after_build'][] = 'gutenberg_form_node_form_text_field_after_build';

  foreach ($text_fields as $fieldname) {
    // For the rest of the text fields call after build to remove
    // Gutenberg from text format options.
    if ($text_fields[0] !== $fieldname) {
      $form[$fieldname]['widget']['#after_build'][] = 'gutenberg_form_node_form_after_build';
    }
  }

  // Let's move the remaining fields to a "special"
  // form group that can be used later by JS to move to
  // Gutenberg's sidebar.
  $form['metabox_fields'] = [
    '#type' => 'details',
    '#access' => TRUE,
    '#title' => t('More settings'),
    '#weight' => 99,
    // Group fallback in case JS fails to move to metaboxes.
    '#group' => 'advanced',
    '#attributes' => [
      'class' => ['more-settings'],
    ],
  ];

  // Move summary field to meta fields
  if (isset($form[$text_fields[0]]['widget'][0]['summary'])) {
    $form['metabox_fields']['summary'] = $form[$text_fields[0]]['widget'][0]['summary'];
    $form['metabox_fields']['summary']['#parents'] = array_merge($form[$text_fields[0]]['widget']['#parents'], ['0', 'summary']);
    unset($form[$text_fields[0]]['widget'][0]['summary']);
  }

  // Some other module might have already init this container.
  if (!isset($form['additional_fields'])) {
    $form['additional_fields'] = [
      '#type' => 'container',
      '#title' => 'Additional',
      '#weight' => -100,
    ];
  }

  // Move title to Published/meta pane.
  $form['title']['#group'] = 'meta';

  // Move status to Published/meta pane.
  $form['status']['#group'] = 'meta';

  // Move langcode to Published/meta pane.
  if (isset($form['langcode'])) {
    $form['langcode']['#group'] = 'meta';
  }

  $excluded_fields = [
    'status',
    'title',
    'uid',
    'created',
    'changed',
    'promote',
    'sticky',
    'path',
    'comment',
    'revision_log',
    'langcode',
  ];

  /*
   * Rationale behind this "messy" algo:
   * If there's any details fieldset on the form, add it to a special array
   * and then, on the form after build, add its #id to a JS array.
   * For any other type of fields, group them on the metabox_fields fieldset.
   * This fieldset will also move to metaboxes area.
   */
  $metabox_has_fields = FALSE;
  $fields_with_details = [];
  $field_names = UtilsController::getEntityFieldNames($node);
  foreach ($field_names as $value) {
    if (
      array_key_exists($value, $form)
      && $value !== $text_fields[0]
      && !in_array($value, $excluded_fields)
    ) {
      if (isset($form[$value]['widget'])
        && isset($form[$value]['widget'][0])
        && isset($form[$value]['widget'][0]['#type'])
        && $form[$value]['widget'][0]['#type'] === 'details') {
        $fields_with_details[] = $value;
      }
      else {
        $form[$value]['#group'] = 'metabox_fields';
        $metabox_has_fields = TRUE;
      }
    }
  }

  $gutenberg_field = $text_fields[0];

  // If any field groups do not have a parent then set the parent as metabox_fields.
  if (!empty($form['#fieldgroups'])) {
    foreach ($form['#fieldgroups'] as &$group) {
      if (empty($group->parent_name)) {
        $group->parent_name = 'metabox_fields';
        $metabox_has_fields = TRUE;
      }
      // If the field with Gutenberg applied to it is in a field group then remove it.
      foreach ($group->children as $key => $child) {
        if ($child == $gutenberg_field) {
          unset($group->children[$key]);
        }
      }
    }
  }

  $form['#after_build'][] = 'gutenberg_form_node_form_details_after_build';
  $form['#fields_with_details'] = $fields_with_details;

  if (!$metabox_has_fields) {
    unset($form['metabox_fields']);
  }

  $theme = \Drupal::theme()->getActiveTheme();
  $theme_name = $theme->getName();
  // Check if current theme is Claro (admin)
  if ($theme_name === 'claro') {
    $form['#attached']['library'][] = 'gutenberg/claro';
  }

  $form['#attached']['drupalSettings']['gutenberg']['metaboxes'][] = 'edit-metabox-fields';

  /** @var \Drupal\Core\Extension\ModuleHandlerInterface $module_handler */
  $module_handler = \Drupal::service('module_handler');
  $form['#attached']['drupalSettings']['gutenberg']['media-enabled'] = $module_handler->moduleExists('media');
  if ($form['#attached']['drupalSettings']['gutenberg']['media-library-enabled'] = $module_handler->moduleExists('media_library')) {
    $form['#attached']['library'][] = 'media_library/ui';
  }
}

/**
 * Store messages in drupal settings.
 */
function gutenberg_handle_messages(&$form) {
  $messages = \Drupal::messenger()->deleteAll();
  $form['#attached']['drupalSettings']['gutenberg']['messages'] = $messages;
}

/**
 * Called by after build text fields on the form.
 */
function gutenberg_form_node_form_after_build(array $element, FormStateInterface $form_state) {
  unset($element[0]['format']['format']['#options']['gutenberg']);
  return $element;
}

/**
 * Called by after build gutenberg field on the form.
 */
function gutenberg_form_node_form_text_field_after_build(array $element, FormStateInterface $form_state) {
  // Hide the format field.
  $element[0]['format']['#attributes']['class'][] = 'hidden';
  return $element;
}

/**
 * Called by form after build.
 */
function gutenberg_form_node_form_details_after_build(array $element, FormStateInterface $form_state) {
  // gutenberg_handle_messages($element);
  foreach ($element['#fields_with_details'] as $value) {
    $element['#attached']['drupalSettings']['gutenberg']['metaboxes'][] = $element[$value]['widget'][0]['#id'];
  }
  return $element;
}

/**
 * Alter media form.
 */
function _gutenberg_media_form_alter(array &$form, FormStateInterface $form_state, string $form_id) {
  $is_gutenberg = !is_null(\Drupal::request()->query->get('gutenberg'));
  if (!$is_gutenberg) {
    return;
  }

  $form['actions']['delete']['#access'] = FALSE;
  unset($form['actions']['delete']);
  $form['#after_build'][] = 'gutenberg_form_media_edit_form_after_build';
  $form['actions']['submit']['#submit'][] = 'gutenberg_form_media_edit_form_submit';
  $form['actions']['submit']['#ajax'] = [
    'callback' => 'gutenberg_form_media_edit_form_submit',
    'event' => 'click',
  ];

  $form['actions']['cancel'] = [
    '#weight' => 99,
    '#type' => 'button',
    '#value' => t('Cancel'),
    '#ajax' => [
      'callback' => 'gutenberg_form_media_edit_form_cancel',
      'event' => 'click',
    ],
  ];
  $form['#submit'][] = 'gutenberg_form_media_edit_form_submit';
}

/**
 * Alter media edit form submit.
 */
function gutenberg_form_media_edit_form_submit(array $form, FormStateInterface $form_state) {
  $form_state->disableRedirect();
  $command = new CloseModalDialogCommand();
  $response = new AjaxResponse();
  $response->addCommand(new UpdateMediaEntitiesCommand());
  $response->addCommand($command);
  return $response;
}

/**
 * Alter media edit form cancel.
 */
function gutenberg_form_media_edit_form_cancel(array $form, FormStateInterface $form_state) {
  $form_state->disableRedirect();
  $command = new CloseModalDialogCommand();
  $response = new AjaxResponse();
  $response->addCommand(new UpdateMediaEntitiesCommand());
  $response->addCommand($command);
  return $response;
}

/**
 * Alter media edit form.
 */
function gutenberg_form_media_edit_form_after_build(array $element, FormStateInterface $form_state) {
  return $element;
}

/**
 * Implements hook_entity_presave().
 */
function gutenberg_entity_presave($entity) {
  if (!_gutenberg_is_gutenberg_enabled($entity)) {
    // Leave early if Gutenberg is not enabled for this entity.
    return;
  }

  /** @var \Drupal\gutenberg\MappingFieldsHelper $mapping_fields */
  $mapping_fields = \Drupal::service('class_resolver')
    ->getInstanceFromDefinition(MappingFieldsHelper::class);

  $mapping_fields->setFieldMappingValues($entity);

}


/**
 * Implements hook_entity_update().
 */
function gutenberg_entity_update($entity) {
  if (!_gutenberg_is_gutenberg_enabled($entity)) {
    // Leave early if Gutenberg is not enabled for this entity.
    return;
  }

  // This was moved to the update and insert hooks because the processBlocks
  // method now requires the node id, and the id is not present yet for new
  // nodes in the presave hook.

  /** @var \Drupal\gutenberg\ContentBlocksHandler $contentBlocksHandler */
  $contentBlocksHandler = \Drupal::service('class_resolver')
    ->getInstanceFromDefinition(ContentBlocksHandler::class);
  $contentBlocksHandler->processBlocks($entity);
}

/**
 * Implements hook_entity_insert().
 */
function gutenberg_entity_insert($entity) {
  gutenberg_entity_update($entity);
}


/**
 * Implements hook_entity_delete().
 */
function gutenberg_entity_delete($entity) {
  if (!_gutenberg_is_gutenberg_enabled($entity)) {
    // Leave early if Gutenberg is not enabled for this entity.
    return;
  }

  \Drupal::service('gutenberg.content_blocks_manager')->deactivateUsageForEntity($entity);
}


/**
 * Implements hook_cron().
 *
 * Delete unused content blocks that were added via gutenberg
 */
function gutenberg_cron(){
  $contentBlocksManager = \Drupal::service('gutenberg.content_blocks_manager');
  // @todo the timestamp here should be configurable, right now its deleting orphans older than 24 hrs.
  $orphans = $contentBlocksManager->getOrphanedBlockIds(strtotime('-24 hours'), 20);
  if($orphans){
    $blocks = \Drupal::entityTypeManager()->getStorage('block_content')->loadMultiple($orphans);
    // delete each block
    foreach($blocks as $block){
      $block->delete();
    }
    // delete usage records.
    $contentBlocksManager->deleteContentBlockUsage($orphans);
  }
}


/**
 * Implements hook_theme_suggestions_HOOK_alter().
 */
function gutenberg_theme_suggestions_node_edit_form_alter(array &$suggestions, array $variables) {
  $contentTypeManager = \Drupal::service('gutenberg.content_type_manager');
  $node_type = $contentTypeManager->getGutenbergNodeTypeFromRoute(\Drupal::routeMatch());
  $gutenberg_enabled = $contentTypeManager->isContentTypeSupported($node_type);

  if (!$gutenberg_enabled) {
    return;
  }

  $suggestions = ['node_edit_form__gutenberg'];
}

/**
 * Implements hook_theme_suggestions_HOOK_alter().
 */
function gutenberg_theme_suggestions_page_alter(array &$suggestions, array $variables) {
  if (!in_array('page__node__edit', $suggestions)
      && !in_array('page__node__add', $suggestions)) {
    return;
  }

  $contentTypeManager = \Drupal::service('gutenberg.content_type_manager');
  $node_type = $contentTypeManager->getGutenbergNodeTypeFromRoute(\Drupal::routeMatch());
  $gutenberg_enabled = $contentTypeManager->isContentTypeSupported($node_type);

  if ($gutenberg_enabled) {
    if (in_array('page__node__edit', $suggestions)) {
      $suggestions[] = 'page__node__edit__gutenberg';
    }

    if (in_array('page__node__add', $suggestions)) {
      $suggestions[] = 'page__node__add__gutenberg';
    }
  }
}

/**
 * Implements hook_element_info_alter().
 */
function gutenberg_element_info_alter(array &$info) {
  if (!empty($info['text_format'])) {
    // Add custom processor to eliminate the format if needed.
    $info['text_format']['#process'][] = '_gutenberg_text_format_processor';
    // Fix double-encryption of whitespaces into &amp;#13;.
    $info['text_format']['#pre_render'][] = [
      GutenbergElementInfoAlter::class, 'preRender',
    ];
  }
}

/**
 * Process the text format element to eliminate the gutenberg format.
 *
 * On the fields that don't belong to content types with enabled gutenberg
 * experience there is no need to have the gutenberg format.
 *
 * @param array $element
 *   Render Element.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   Form state object.
 * @param array $complete_form
 *   Complete form array.
 *
 * @return array
 *   Processed render element.
 */
function _gutenberg_text_format_processor(array $element, FormStateInterface $form_state, array &$complete_form) {
  // Check first if the format is in the list. It might be disabled or the
  // current user has not rights to access it.
  if (!empty($element['format']) && isset($element['format']['format']['#options']['gutenberg'])) {
    // By default let's assume that gutenberg format is not allowed.
    $gutenberg_allowed = FALSE;
    /** @var \Drupal\Core\Entity\ContentEntityForm $form */
    $form = $form_state->getFormObject();
    // Check whether the form that contains the element is an EntityForm.
    if ($form instanceof EntityFormInterface) {
      // Get the entity from the form object for further processing.
      $entity = $form->getEntity();
      // Check whether entity is of node type, because currently only them are
      // supported.
      if ($entity instanceof NodeInterface) {
        // Get the node type to get the Gutenberg experience setting.
        $node_type = $entity->bundle();
        /** @var \Drupal\Core\Config\Config $config */
        $config = \Drupal::service('config.factory')
          ->getEditable('gutenberg.settings');
        $gutenberg_enabled = $config->get($node_type . '_enable_full');
        if (!empty($gutenberg_enabled)) {
          // Gutenberg experience is enabled for current content type and
          // the current user is allowed to use the format.
          $gutenberg_allowed = TRUE;
        }
      }
    }
    // If Gutenberg experience is not enabled for the current form or
    // current user is not allowed to use the format, disable the choice of
    // Gutenberg format for this element.
    if (!$gutenberg_allowed) {
      unset($element['format']['format']['#options']['gutenberg']);
    }
  }
  return $element;
}

/**
 * Implements hook_views_pre_render().
 */
function gutenberg_views_pre_render(ViewExecutable $view) {
  if ($view->id() == "reusable_blocks" && $view->current_display == 'page_1') {
    // Attached Gutenberg's basic style to reusable blocks view.
    $view->element['#attached']['library'][] = 'gutenberg/admin';
    $view->element['#attached']['library'][] = 'gutenberg/blocks-view';
  }
}

/**
 * Implements hook_page_attachments().
 */
function gutenberg_page_attachments(array &$page) {
  /** @var \Drupal\gutenberg\GutenbergLibraryManagerInterface $gutenberg_library_manager */
  $gutenberg_library_manager = \Drupal::service('plugin.manager.gutenberg.library');

  // Get color palette CSS if available/enabled.
  $css_markup = $gutenberg_library_manager->generateThemeColorClasses();
  if ($css_markup) {
    $page['#attached']['html_head'][] = [
      [
        '#tag' => 'style',
        '#attributes' => [
          'id' => Html::getUniqueId('gutenberg-palette'),
        ],
        '#value' => $css_markup,
      ],
      'gutenberg_palette',
    ];
  }

  // Get gradients CSS if available/enabled.
  $css_markup = $gutenberg_library_manager->generateThemeGradientClasses();
  if ($css_markup) {
    $page['#attached']['html_head'][] = [
      [
        '#tag' => 'style',
        '#attributes' => [
          'id' => Html::getUniqueId('gutenberg-gradients'),
        ],
        '#value' => $css_markup,
      ],
      'gutenberg_gradients',
    ];
  }

  // Get gradients CSS if available/enabled.
  $css_markup = $gutenberg_library_manager->generateThemeFontSizeClasses();
  if ($css_markup) {
    $page['#attached']['html_head'][] = [
      [
        '#tag' => 'style',
        '#attributes' => [
          'id' => Html::getUniqueId('gutenberg-font-sizes'),
        ],
        '#value' => $css_markup,
      ],
      'gutenberg_font_sizes',
    ];
  }

  // Get spacing sizes variables if available.
  $css_markup = $gutenberg_library_manager->generateSpacingSizesCssVariables();
  if ($css_markup) {
    $page['#attached']['html_head'][] = [
      [
        '#tag' => 'style',
        '#attributes' => [
          'id' => Html::getUniqueId('gutenberg-spacing-variables'),
        ],
        '#value' => $css_markup,
      ],
      'gutenberg_spacing_variables',
    ];
  }

  $stores = StyleEngine::get_stores();

	foreach ( array_keys( $stores ) as $store_name ) {
		$styles = StyleEngine::gutenberg_style_engine_get_stylesheet_from_context( $store_name );
    if ( ! empty( $styles ) ) {
      $page['#attached']['html_head'][] = [
        [
          '#tag' => 'style',
          '#attributes' => [
            'id' => Html::getUniqueId("gutenberg-style-engine-$store_name"),
          ],
          '#value' => Markup::create($styles),
        ],
        "gutenberg-style-engine-$store_name",
      ];
  
			// $key = "wp-style-engine-$store_name";
			// wp_register_style( $key, false, array(), true, true );
			// wp_add_inline_style( $key, $styles );
			// wp_enqueue_style( $key );
		}
	}
}

/**
 * Implements hook_library_info_alter().
 */
function gutenberg_library_info_alter(&$libraries, $extension) {
  if ($extension === 'gutenberg') {
    $moduleHandler = \Drupal::moduleHandler();
    $js_files_edit = [];
    $css_files_edit = [];
    $css_files_view = [];
    $moduleHandler->alter('gutenberg_blocks', $js_files_edit, $css_files_edit, $css_files_view);

    foreach ($js_files_edit as $file) {
      $libraries['blocks-edit']['js'][$file] = [];
    }

    foreach ($css_files_edit as $file) {
      $libraries['blocks-edit']['css']['base'][$file] = [];
    }

    foreach ($css_files_view as $file) {
      $libraries['blocks-edit']['css']['base'][$file] = [];
      $libraries['blocks-view']['css']['base'][$file] = [];
    }

    // Workaround for aggregation errors in Drupal core when applied on already
    // minified files. Skipping all Gutenberg JS files from aggregation.
    // See https://www.drupal.org/project/gutenberg/issues/3372307.
    foreach ($libraries as $name => &$library) {
      if (empty($library['js'])) {
        continue;
      }

      foreach ($library['js'] as $file => &$properties) {
        $properties['minified'] = TRUE;
        $properties['preprocess'] = FALSE;
      }
    }
  }
}

/**
 * Implements hook_help().
 */
function gutenberg_help($route_name, RouteMatchInterface $route_match) {
  if ($route_name === 'help.page.gutenberg') {
    $readme_file = file_exists(__DIR__ . '/README.md') ? __DIR__ . '/README.md' : __DIR__ . '/README.txt';
    if (!file_exists($readme_file)) {
      return NULL;
    }
    $text = file_get_contents($readme_file);
    if (!\Drupal::moduleHandler()->moduleExists('markdown')) {
      return '<pre>' . $text . '</pre>';
    }
    else {
      // Use the Markdown filter to render the README.
      $filter_manager = \Drupal::service('plugin.manager.filter');
      $settings = \Drupal::configFactory()->get('markdown.settings')->getRawData();
      $config = ['settings' => $settings];
      $filter = $filter_manager->createInstance('markdown', $config);
      return $filter->process($text, 'en');
    }
  }
  return NULL;
}

/**
 * Implements hook_themes_installed().
 */
function gutenberg_themes_installed($theme_list) {
  \Drupal::service('plugin.manager.gutenberg.library')->clearCachedDefinitions();
}

/**
 * Implements hook_themes_uninstalled().
 */
function gutenberg_themes_uninstalled(array $themes) {
  \Drupal::service('plugin.manager.gutenberg.library')->clearCachedDefinitions();
}

/**
 * Checks whether Gutenberg is enabled for an entity.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity to check.
 *
 * @return bool
 *   Whether the entity is supported.
 */
function _gutenberg_is_gutenberg_enabled(EntityInterface $entity = NULL) {
  if (!$entity) {
    return FALSE;
  }

  if ($entity->getEntityTypeId() !== 'node') {
    return FALSE;
  }

  /*
   * TODO read from the entity type's third_party_settings instead of a global.
   *  @see menu_ui_form_node_form_alter() and
   *  https://www.sitepoint.com/drupal-8-third-party-settings-and-pseudo-fields/
   */
  $config = \Drupal::service('config.factory')->get('gutenberg.settings');
  $node_type = $entity->bundle();

  return (bool) $config->get($node_type . '_enable_full');
}

/**
 * Implements hook_module_implements_alter().
 */
function gutenberg_module_implements_alter(&$implementations, $hook) {
  switch ($hook) {
    // Move our hook_form_alter() implementation to the end of the list.
    case 'form_alter':
      $group = $implementations['gutenberg'];
      unset($implementations['gutenberg']);
      $implementations['gutenberg'] = $group;
      break;
  }
}
